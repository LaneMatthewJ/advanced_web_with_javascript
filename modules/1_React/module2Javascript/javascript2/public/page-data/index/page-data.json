{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","result":{"data":{"deck":{"id":"f390d2b2-5506-5923-8d8b-543ba0cfaf23","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"MORE Javascript!\"), mdx(\"hr\", null), mdx(\"h2\", null, \"The Event Loop:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Imagine that every single tab in your web browser is running on a constant loop. Javascript code is entirely single threaded, that is to say, there are no other threads or processes that get kicked off. While this does seemingly limit the abilities of your program, it does simplify your code (i.e. you don't need to worry about listening for other threads). All you need to think about is how to create code that does not block (e.g. no \\\"event listener loops\\\" that spin forever).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Expensive calls in javascript (such as network calls) that could block the event loop are non-blocking.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"The Event Loop:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The event loop looks to see if there is anything in the call stack that can be run. Regularly speaking, think of this as a stack trace.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sayHi = () => console.log(\\\"hi\\\");\\nconst sayGoodbye = () => console.log(\\\"goodbye\\\");\\n\\nconst interact = () => {\\n  sayHi();\\n  sayGoodbye();\\n};\\n\\ninteract();\\n\")), mdx(\"p\", null, \"outputs:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"hi\\ngoodbye\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"The Event Loop:\"), mdx(\"p\", null, \"But what happens if there's a blocking element?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sayHi2 = () => console.log(\\\"hi\\\");\\nconst saySomethingEngaging = () => console.log(\\\"I live in a giant shoe\\\");\\nconst sayGoodbye2 = () => console.log(\\\"goodbye\\\");\\n\\nconst interact2 = () => {\\n  sayHi2();\\n  setTimeout(saySomethingEngaging, 500);\\n  sayGoodbye2();\\n};\\n\\ninteract2();\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Once the timer is finished, saySomethingEngaging is placed into the message queue (also where user inputs go) to be retrieved by the loop. Priority is given to the call stack (i.e. everything that's not waiting in the message queue).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"output:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"> interact2()\\nhi\\ngoodbye\\n\\n> I live in a giant shoe\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Asynchronous Programming, Promises, and Async/Await\"), mdx(\"p\", null, \"Because javascript is single threaded, it's synchronous by default. So how do we get around that? With asynchronous programming!\"), mdx(\"hr\", null), mdx(\"h3\", null, \"Callbacks:\"), mdx(\"p\", null, \"Callbacks are functions that are passed to other functions that act as listeners.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"document.querySelector(\\\"button\\\").addEventListener(\\\"click\\\", () => {\\n  console.log(\\\"Call me back!\\\");\\n});\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To account for error handling, the first parameter of every callback is typically error, with the second parameter being the desired input (we'll see examples of this in a couple slides)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Callbacks can be very helpful, however, they can very easily result in the \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://medium.com/dsc-srm/javascript-callback-hell-or-pyramid-of-doom-4f786d14b997\"\n  }), \"pyramid of doom! (aka callback hell)\"))), mdx(\"hr\", null), mdx(\"h3\", null, \"Promises\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Promises are one way to get around the pyramid of doom\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ultimately, whena promise is called, it gets placed into its \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"pending\"), \" state (neither fulfilled or rejected), while the remaining, nonblocking code executes.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Promises resolve to either:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"fulfilled\"), \": the operation was successful\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"rejected\"), \": the operation failed\")))))), mdx(\"hr\", null), mdx(\"h3\", null, \"Promises\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the promise is resolved, the respective handlers are called:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".then()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".catch()\"))))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const successfulPromise = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    resolve(\\\"Huzzah!\\\");\\n  }, 500);\\n});\\n\\nconsole.log(\\\"Successful Promise: \\\", successfulPromise);\\n\\nsuccessfulPromise.then(whateverWasResolved => {\\n  console.log(\\\"Neat! we resolved \\\" + whateverWasResolved);\\n});\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Promises\"), mdx(\"p\", null, \"While the previous code is fine, it is still somewhat clunky. We can further condense it by chaining our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".methods\"), \" (and getting ride of that middle log):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const successfulPromise2 = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    resolve(\\\"Huzzah!\\\");\\n  }, 500);\\n}).then(whateverWasResolved => {\\n  console.log(\\\"Neat! we resolved \\\" + whateverWasResolved);\\n});\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Promises\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The same goes for rejected promises:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const rejectedPromise = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    reject(\\\"Not Huzzah!\\\");\\n  }, 500);\\n}).catch(err => {\\n  console.log(\\\"Neat! we got rejected! \\\" + err);\\n});\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Promises\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let whoKnowsWhatKindOfPromise6 = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    Math.random() > 0.5 ? resolve(\\\"Huzzah!\\\") : reject(\\\"Nuhzah\\\");\\n  }, 500);\\n})\\n  .then(whateverWasResolved => {\\n    console.log(whateverWasResolved);\\n  })\\n  .catch(err => {\\n    console.error(err);\\n  });\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Async / Await\"), mdx(\"p\", null, \"Built on top of promises, async/awati makes the syntax a bit more readable: When calling an asynchronous function you need to follow the syntax of:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const functionName = async parameter => {\\n  await someAsynchronousFunction();\\n};\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Async / Await\"), mdx(\"p\", null, \"In real code, async await would look something akin to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const someAsynchronousFunction = () => {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(\\\"Taking our time!\\\");\\n    }, 500);\\n  });\\n};\\n\\nconst useAsyncAwait = async () => {\\n  await someAsynchronousFunction();\\n};\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Async / Await\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now, instead of having a series of callbacks or promise.then's, we can use async await to wait on the responses from asynchronous calls and use them in a single code block:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const asyncFunc = async () => {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(\\\"Taking our time!\\\");\\n    }, 500);\\n  });\\n};\\n\\nconst asyncFunc2 = async () => {\\n  return 23;\\n};\\n\\nconst callingAsync = async () => {\\n  const response = await asyncFunc();\\n  const response2 = await asyncFunc2();\\n\\n  console.log(\\\"response is\\\", response);\\n  console.log(\\\"response2 is\\\", response2);\\n};\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms:\"), mdx(\"p\", null, \"There are a number of array manipulation methods to be familiar with as we move forward:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"map\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"reduce\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"filter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"find\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms:\"), mdx(\"p\", null, \"Some Data:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const officeFolk = [\\n  { name: \\\"Michael Scott\\\", salary: 70000 },\\n  { name: \\\"Dwight Schrute\\\", salary: 40000 },\\n  { name: \\\"Jim Halptert\\\", salary: 40000 },\\n  { name: \\\"Pam Beesly\\\", salary: 30000 },\\n  { name: \\\"Ryan Howard\\\", salary: 0 },\\n  { name: \\\"Andy Bernard\\\", salary: 40000 },\\n  { name: \\\"Robert California\\\", salary: 1000000 },\\n  { name: \\\"Stanley Hudson\\\", salary: 50000 },\\n  { name: \\\"Creed Branton\\\", salary: 40000 },\\n  { name: \\\"Meredith Palmer\\\", salary: 40000 },\\n  { name: \\\"Phyllis Lapin\\\", salary: 50000 }\\n];\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms: Map\"), mdx(\"p\", null, \"Instead of writing a loop that can potentially manipulate data in a list, it is better to use a map to read data and return a new list of some given kind based off of the data that you already have. Suppose we would like to get a list only of the names of the characters above:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const characterNames = officeFolk.map(officePerson => {\\n  return officePerson.name;\\n});\\n\\nconsole.log(characterNames);\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms: Map\"), mdx(\"p\", null, \".map takes a function as a parameter, where the parameter for the function is each individual element of the list. We could easily write the function separately such as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const retrieveOfficeCharacterName = officeCharacter => {\\n  return officeCharacter.name;\\n};\\n\\nconst characterNameList = officeFolk.map(retrieveOfficeCharacterName);\\n\\nconsole.log(characterNameList);\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms: Reduce\"), mdx(\"p\", null, \"Reduce is a function that iterates over a list and has an accumulator. Suppose we wanted the total sum of all the salaries of the office characters:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const salarySum = officeFolk.reduce((accumulator, officeCharacter) => {\\n  return accumulator + officeCharacter.salary;\\n}, (accumulator = 0));\\n\\nconsole.log(\\\"Total salary is \\\", salarySum);\\n\")), mdx(\"p\", null, \"What we do is start with a given value (accumulator = 0), and then for each item within the list, we execute the supplied function, and update the accumulator.\"), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms: Filter\"), mdx(\"p\", null, \"When you wish to receive a list from another list that adheres to some specific set of criteria, filter is the best option. To get a list of all office characters who have salaries over 60,000, we'd write an anonymous function that returns a boolean value:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const higherSalaries = officeFolk.filter( officeCharacter => officeCharacter.salary >== 60000)\\n\\nconsole.log(higherSalaries)\\n\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms: Find\"), mdx(\"p\", null, \"Find will retrieve a value from the list by passing a function that returns a boolean value (just like the filter function):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const noSalary = officeFolk.find(character => character.salary === 0);\\n\\nconsole.log(noSalary);\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Functional Programming Paradigms: Find\"), mdx(\"p\", null, \"As a note, however, find will not return ALL values that match, but only the first value that matches:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fortyThousandSalary = officeFolk.find(\\n  character => character.salary === 40000\\n);\\n\\nconsole.log(fortyThousandSalary);\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","id":"f390d2b2-5506-5923-8d8b-543ba0cfaf23","slug":"","title":"MORE Javascript!"}}}